def checkTasks = []
gradle.rootProject.allprojects { project ->
    checkTasks.addAll(project.tasks.findAll { it.name == 'build' })
}

def final TARGET_SPACE = 'space'
def final PRODUCTION_SPACE = 'contributor-license-agreements'
def final STAGING_SPACE = 'contributor-license-agreements-staging'

// Gather information about the build environment. Is it a Travis CI build?
def travisBranch = System.getenv().get("TRAVIS_BRANCH")
def hasSecureEnv = Boolean.valueOf(System.getenv().get("TRAVIS_SECURE_ENV_VARS"))
def isPullRequest = Boolean.valueOf(System.getenv().get("TRAVIS_PULL_REQUEST"))
def isTravisBuild = travisBranch != null
def isDeployableTravisBuild = isTravisBuild && (!isPullRequest || hasSecureEnv)

// User may specify an explicit target space any time, e.g. ./gradlew deploy -Pspace=production
// Otherwise, target space will be determined by branch name (assuming we are in a Travis CI build).
// If no branch is matched, no space is set, and deployment will be skipped entirely.

if (!project.hasProperty(TARGET_SPACE) && travisBranch != null) {
    if (travisBranch =~ '^master$') {
        project.ext.setProperty(TARGET_SPACE, PRODUCTION_SPACE)
    } else if (travisBranch =~ '^stage-.*') {
        project.ext.setProperty(TARGET_SPACE, STAGING_SPACE)
    }
}

task deploy(dependsOn: [build]) {
    description = 'Deploys the project to a Cloud Foundry space (specified with -Pspace=<targetspace>)'
    mustRunAfter checkTasks

    // Always proceed with deployment if it is a local build. If we're on Travis CI, only
    // deploy if the secure environment vars are available (i.e. this is not a pull request
    // from a fork) and we're on a branch intended for production deployment.
    if (!isTravisBuild || (isDeployableTravisBuild && project.hasProperty(TARGET_SPACE))) {
        dependsOn 'cfLogin'

        dependsOn 'cfDeploy', 'cfSwapDeployed'
    } else {
        onlyIf { false }
    }
}

apply plugin: 'cloudfoundry'

cloudfoundry {
    target = "https://api.run.pivotal.io"
    organization = "FrameworksAndRuntimes"
    application = 'pivotal-cla'

    host = "$application"
    domain = 'cfapps.io'
    memory = 1024
    variants = ['-blue', '-green']
    healthCheckTimeout = 180
    instances = 2
    buildpack = 'https://github.com/cloudfoundry/java-buildpack/'
}

// These deployment properties can be set on the command line with "-P" options or in "gradle.properties",
// All are required if the respective 'cfLogin' / 'deploy' tasks
// have been invoked.

def reqDeployVars = [
        'security.oauth2.main.clientId', 'security.oauth2.main.clientSecret',
        'security.oauth2.pivotal-cla.tokenSecret'
]

gradle.taskGraph.whenReady {
    if (isTravisBuild && !isDeployableTravisBuild) {
        // Skip deployment altogether when building pull requests from forks under Travis CI
        project.tasks.findByPath("deploy").onlyIf { false }
    } else {
        // We should have everything we need in order to deploy. Check for required credentials
        // and populate cloudfoundry environment variables.
        if (gradle.taskGraph.hasTask(":cfLogin")) {
            def missingVars = []

            if (!project.hasProperty('cfUsername')) {
                missingVars << 'cfUsername'
            }
            if (!project.hasProperty('cfPassword')) {
                missingVars << 'cfPassword'
            }
            if (missingVars.size() > 0) {
                throw new InvalidUserDataException(
                        "Missing required variable(s) for the 'cfLogin' task: ${missingVars}. " +
                                "Specify them with -Pkey=value");
            }
        }

        if (gradle.taskGraph.hasTask(":${deploy.name}")) {
            def missingVars = []
            reqDeployVars.each { var ->
                if (!project.hasProperty(var)) {
                    missingVars << var
                }
            }
            if (missingVars.size() > 0) {
                throw new InvalidUserDataException(
                        "Missing required variable(s) for the 'deploy' task: ${missingVars}. " +
                                "Specify them with -Pkey=value");
            }

            // All required env vars are present. Populate the cloudfoundry environment with them.
            cloudfoundry {
                env << [
                        "SECURITY_OAUTH2_MAIN_CLIENT_ID"         : project.ext.'security.oauth2.main.clientId',
                        "SECURITY_OAUTH2_MAIN_CLIENT_SECRET"     : project.ext.'security.oauth2.main.clientSecret',
                        "SECURITY_OAUTH2_PIVOTAL-CLA_TOKENSECRET": project.ext.'security.oauth2.pivotal-cla.tokenSecret',
                        "SPRING_PROFILES_ACTIVE": "cloudfoundry",
                ]
            }

        }
    }
}

// Routes can be specified by combining the 'host'/'hosts' field with the 'domain' field, or by the 'uri'/'uris' field.
// Values for 'host'/'hosts' are modified on cfDeploy to add '-blue' or '-green' as appropriate, and are applied on
// cfPush and cfDeploy. Values for 'uri'/'uris' are never modified with '-blue' or '-green', and are only applied by
// cfPush and cfSwapDeployed. Using both forms of specifying routes gives control over which routes are decorated and
// which routes are undecorated.

if (project.hasProperty(TARGET_SPACE)) {
    cloudfoundry {
        space = project.getProperty(TARGET_SPACE)
        host = "$application-${space}"

        env << [
                SPRING_PROFILES_ACTIVE: "${space}",
        ]

        services {
            'pivotal-cla-redis' {
                label = 'rediscloud'
                plan = '30mb'
            }

            'pivotal-cla-mysql' {
                label = 'p-mysql'
                plan = '1gb'
            }
        }
    }

    cloudfoundry {
        uris = (space == PRODUCTION_SPACE ? ["pivotal-cla.cfapps.io"] : ["${space}.cfapps.io"])
    }
}
